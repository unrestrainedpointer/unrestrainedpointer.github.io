---
title: Interview-Database
date: 2022-04-23 13:23:42
tags: Computer Science
---
1. 数据库三大范式：
   1. 第一范式：列不可拆分；
   2. 第二范式：非主键依赖主键而非主键的一部分；
   3. 第三范式：非主键只依赖主键而非其他非主键；
2. MySQL的binlog有几种录入格式？分别有什么区别？
   1. statement：只记录SQL语句而不记录每一行的变化，减少了binlog的记录量，节约了IO提高了性能；
   2. row：记录了每一行的变化，但是文件的保存信息太多，日志量太大；
   3. mixed：普通操作使用statement记录，无法使用statement的时候使用row；
3. MyISAM索引和InnoDB索引的区别：
4. InnoDB引擎的4大特性：
   1. 插入缓冲：
   2. 二次写：
   3. 自适应哈希索引：
   4. 预读：
5. 索引的类型：
   1. 主键索引：数据列不允许重复，不允许为null，一个表只能有一个主键。
   2. 唯一索引：数据列不允许重复，允许为null，一个表允许多个列创建唯一索引。
   3. 普通索引，没有唯一性的限制，允许为null。
   4. 全文索引；
6. 最左前缀匹配原则：mysql可以创建联合索引即多列的索引，一个索引可以包含最多16列。
7. 聚簇索引：将数据和索引存储到一起；
8. 非聚簇索引：数据和索引分开存放，索引的叶子节点指向数据的对应行；
9. 联合索引：
10. 事务：一个不可分割的数据库操作系列，也是数据库并发控制的基本单位，其执行结果必须使数据库从一种一致性状态转变为另一种一致性状态。
11. 事务的四大特性ACID：
    1.  原子性：事务是最小执行单位，不允许分割。事务的原子性是通过undo log日志进行实现的，当事务需要回滚的时候，InnoDB就调用undo log日志进行SQL语句的撤销，实现数据的回滚；
    2.  一致性：多个事务对同一个数据读取的结果是相同的；
    3.  隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间的数据库是独立的；
    4.  持久性：事务提交后对数据库的改变是不受故障等因素影响的，事务的持久性是通过InnoDB存储引擎中的redo log日志来实现的；
12. 脏读、幻读、不可重复读：
    1.  脏读：一个事务更改数据还未提交，另一个事务在此时就读了还未提交的数据，如果另一个事务回滚了或者没有顺利提交，那么这个数据就没有被修改，但这个没有修改的数据却被读了，这显然不合理；
    2.  不可重复读：一个事务在两次查询之中数据不一致；
    3.  幻读：先后两此查询的数据得到的行数不同；
13. 事务隔离级别：为了达到事务的四大特性，数据库定义了4种不同的事务隔离别；
    1.  Read-uncommitted：允许读取尚未提交的数据变更，可能导致脏读、不可重复读、幻读；
    2.  Read committed：允许读取并发事务已提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
    3.  Repeatable read：可重复读，对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己修改的，可以阻止脏读和不可重复读，但幻读仍有可能发生。
    4.  Serializable：可串行化，所有事务一次逐个执行，完全符合ACID；
14. 隔离级别与锁的关系：
    1.  在Read uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突；
    2.  Read committed级别下读操作需要加共享锁，但是在语句执行完以后释放共享锁；
    3.  Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁；
    4.  Serializable：该级别锁定整个范围的键，并一直持有锁，直到事务完成；
15. 锁分类：
    1.  行级锁：只针对当前操作的行进行加锁，行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但开锁的开销也最大，行级锁分为共享锁和排他锁，有死锁；
    2.  表级锁：对当前操作的整张表加锁。实现简单消耗资源少。表级锁分为共享读锁和独占写锁（排他锁），开销小，加锁快，无死锁。
    3.  页级锁：粒度介于行级锁和表级锁中间的一种锁，表级锁加速快，但冲突多，行级锁冲突少，但速度慢。所以取了折中的页级，一次锁定相邻的一组记录；
16. 共享锁和排他锁：
    1.  共享锁又叫读锁，当用户要进行数据的读取时对数据加上共享锁。
    2.  排他锁又叫写锁：排他锁只可以加一个，它和其他的排他锁、共享锁互斥；
17. InnoDB存储引擎的锁算法有哪三种？
    1.  Record lock：单个行记录上的锁；
    2.  Gap Lock：间隙锁，锁定一个范围，不包括记录本身；
    3.  Next-key lock：锁定一个范围包括范围本身；
18. MySQL的主从复制：
    1.  将原来的数据库复制一个一样的，原来的叫主数据库，复制的叫从数据库。从数据库会与主数据库进行数据同步，保持二者的数据一致性；
    2.  主从复制的原理是通过binlog日志实现的。binlog日志中保存了数据库中所有SQL语句，通过对binlog日志中SQL的复制，然后再进行语句的执行即可实现同步；
    3.  实现主从复制主要靠三个线程：运行在主服务器的发送线程，用于发送binlog到从服务器，运行在从服务器上的I/O线程用于读取从主服务器发来的binlog内容并拷贝到本地的中继日志中，运行在从服务器上的SQL线程用于读取中继日志中关于数据更新的SQL语句并执行，从而实现主从库的数据一致；
19. MVCC：Multi-Version Concurrency Control，多版本并发控制协议，实现Repeatable Read隔离级别的机制；
20. redo log日志是InnoDB引擎层的日志，用来记录事务操作引起数据的变化，记录的是数据页的物理修改：
    1.  预写式技术：InnoDB引擎对数据的更新，是先将更新数据记录写入redo log日志，然后在系统空闲的时候或者是按照设定的更新策略再将日志中的内容更新到磁盘中。
    2.  redo log的大小是固定的，为了能够持续不断的对更新记录进行写入，在redo log日志中设置了两个标志位，checkpoint和write_pos，分别记录了擦除的位置和写入的位置，[write_pos, checkpoint]之间是可写入的区间；
    3.  当write_pos标志到了日志结尾时，会从结尾跳到日志头部，重新循环写入。
    4.  当write_pos追上checkpoint表示redo log已经写满，需要停下来删除一些记录，执行checkpoint规则腾出可写空间；
    5.  checkpoint规则：checkpoint触发后，将buffer中脏数据页和脏日志页都刷新到磁盘；
    6.  脏数据：内存中未刷到磁盘的数据；
    7.  redo log中最重要的概念就是缓冲池buffer pool，这是在内存中分配的一个区域，包含了磁盘中部分数据页的映射，作为访问数据库的缓冲；
    8.  当请求读取数据时，会先判断是否在缓冲池命中，如果未命中才会在磁盘上进行检索后放入缓冲池；
    9.  当请求写入数据时，会先写入缓冲池，缓冲池中修改的数据会定期刷新到磁盘中。这一过程也称为刷脏；
    10. 因此，当数据修改时，除了修改buffer pool中的数据，还会在redo log中记录这次操作；当事务提交时，会根据redo log的记录对数据进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复，从而保证了事务的持久性。
21. 脏日志刷盘：
    1.  为了保证日志文件的持久化，也需要经历将日志记录从内存写入磁盘的过程。redo log分为两部分，一是存在易失性内存中的缓存日志redo log buff，二是保存在磁盘上的redo log file；
    2.  脏日志刷盘调用操作系统的fsync操作，fsync函数用于同步内存中所有已修改的文件数据到储存设备；
22. 二进制日志binlog：是一种服务层日志，所有引擎都可以使用；
    1.  还称为归档日志，记录数据库的变化情况。所有涉及数据变动的操作都要记录其中。因此有了binlog可以很方便的对数据进行复制和备份，因而也常用作主从库的同步；
    2.  binlog输入磁盘的几种模式：
        1.  STATEMENT：基于SQL语句的复制；
        2.  ROW：基于行的复制——被修改的行写入binlog；
        3.  MIXED：基于上述两种的混合复制；
    3.  binlog和redo log的区别：
        1.  redo log是一种物理日志，记录的是实际数据库中数据页上的变化信息，即某个位置变成了什么数据；
        2.  binlog是一种逻辑日志，是记录操作的，比如sql语句，也可以记录某一行数据变0化或者二者结合——一般的复制使用STATEMENT，对于STATEMENT模式无法复制的操作使用ROW模式保存；
        3.  redo log是基于crash recovery，保证MySQL宕机后的数据恢复；而binlog是基于point-in-time recovery，保证服务器可以基于时间点对数据进行恢复，或者对数据进行备份；
        4.  binlog是追加写入，不会覆盖已写文件，redo log日志是循环写入和擦除；
23. 回滚日志undo log：引擎层日志；
    1.  当数据库修改时除了记录redo log还会生成对应的undo log，如果事务执行失败或者调用了rollback，就利用undolog将数据回滚到修改之前的样子；
    2.  undo log不同于redo log，它属于逻辑日志，它对SQL语句执行相关的信息进行记录。当发生回滚时，InnoDB引擎会根据undo log日志中的记录做与之相反的工作。
    3.  undo日志一个是提供回滚操作，二是实现MVCC；
24. 一条SQL语句的执行过程：
    1.  连接建立；
    2.  SQL查询解析器：类似于编译；
    3.  SQL查询优化器：优化SQL语句，生成执行计划，选择相应索引，选择相应的引擎去执行SQL；
    4.  执行器：调用存储引擎接口执行SQL语句；
    5.  存储引擎读取Buffer Pool缓冲，未命中则去磁盘中查找；
    6.  将这条语句加载到undo log中；
    7.  redo log将数据被修改后的情况记录在redo log buffer中；
    8.  事务被提交时，将redo log buffer中的数据写入redo log file中；
    9.  将本次记录写入binlog文件；
    10. 将binlog文件名字和更新内容在binlog中的位置记录在redo log中，同时在redo log最后添加commit标记；
25. 索引失效：
    1.  违反最左前缀原则
    2.  在索引列上使用内置函数；
    3.  查询条件包含or
    4.  使用不等于
    5.  like以通配符开头
    6.  字符串不加单引号
    7.  当mysql估计使用全表扫描要比使用索引快，则不使用索引
26. InnoDB和MyISAM的区别：
    1.  InnoDB支持事务，MyISAM不支持事务；
    2.  InnoDB支持外键，MyISAM不支持外键；
    3.  InnoDB支持MVCC，MyISAM不支持；
    4.  MyISAM有一个变量保存了整个表的总行数，可以直接读取总行数，而InnoDB需要扫描全表；
    5.  InnoDB支持表、行级锁，MyISAM只支持表级锁；
    6.  InnoDB必须有主键，而MyISAM可以没有主键；
    7.  InnoDB按主键大小有序插入，MyISAM记录是按插入顺序保存；
27. MySQL的索引：
    1.  按数据结构维度：
        1.  B+树索引；
        2.  哈希索引；
        3.  全文索引；
        4.  R-Tree索引；
    2. 物理存储维度：
       1. 聚簇索引；
       2. 非聚簇索引；
    3. 逻辑维度：
       1. 主键索引；
       2. 普通索引；
       3. 联合索引；
       4. 唯一索引；
       5. 空间索引；
